/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Generic blockchain interface for blockchain operations */
export interface BlockchainCallback {
  /** Function name to call for getting block data */
  getBlockData: string
  /** Function name to call for submitting checkpoints */
  submitCheckpoint: string
  /** Function name to call for getting current block height */
  getCurrentHeight: string
}
/** Generic token interface for economic operations */
export interface TokenCallback {
  /** Function name to call for creating bonds */
  createBond: string
  /** Function name to call for releasing bonds */
  releaseBond: string
  /** Function name to call for slashing bonds */
  slashBond: string
  /** Function name to call for paying rewards */
  payReward: string
}
/** Generic randomness beacon interface */
export interface BeaconCallback {
  /** Function name to call for getting beacon randomness */
  getRandomness: string
  /** Function name to call for verifying beacon signature */
  verifyRandomness: string
}
/** Generic network interface for latency proofs */
export interface NetworkCallback {
  /** Function name to call for measuring network latency */
  measureLatency: string
  /** Function name to call for verifying peer location */
  verifyPeerLocation: string
  /** Function name to call for getting network peers */
  getNetworkPeers: string
}
/** Multi-source entropy combining blockchain, beacon, and local sources */
export interface MultiSourceEntropy {
  /** Blockchain block hash entropy */
  blockchainEntropy: Buffer
  /** External beacon entropy (optional) */
  beaconEntropy?: Buffer
  /** Local randomness */
  localEntropy: Buffer
  /** Timestamp when entropy was collected */
  timestamp: number
  /** Combined entropy hash */
  combinedHash: Buffer
}
/** Memory-hard VDF proof structure */
export interface MemoryHardVdfProof {
  /** Input state to VDF */
  inputState: Buffer
  /** Output state from VDF */
  outputState: Buffer
  /** Number of iterations performed */
  iterations: number
  /** Sample of memory access pattern (for verification) */
  memoryAccessSamples: Array<MemoryAccessSample>
  /** Total computation time in milliseconds */
  computationTimeMs: number
  /** Memory usage in bytes */
  memoryUsageBytes: number
}
/** Sample of memory access for VDF verification */
export interface MemoryAccessSample {
  /** Iteration number when sample was taken */
  iteration: number
  /** Memory read address */
  readAddress: number
  /** Memory write address */
  writeAddress: number
  /** Hash of memory content at read address */
  memoryContentHash: Buffer
}
/** Availability challenge structure */
export interface AvailabilityChallenge {
  /** Chain being challenged */
  chainId: Buffer
  /** Chunk index to retrieve */
  chunkIndex: number
  /** Challenge nonce */
  challengeNonce: Buffer
  /** Challenger identifier */
  challengerId: Buffer
  /** Challenge timestamp */
  challengeTime: number
  /** Response deadline */
  deadline: number
  /** Reward amount for successful challenge */
  rewardAmount: number
}
/** Response to availability challenge */
export interface AvailabilityResponse {
  /** Challenge being responded to */
  challengeId: Buffer
  /** Actual chunk data */
  chunkData: Buffer
  /** Response timestamp */
  responseTime: number
  /** Proof of chunk authenticity */
  authenticityProof: Buffer
}
/** Network latency proof for anti-outsourcing */
export interface NetworkLatencyProof {
  /** List of peer latency measurements */
  peerLatencies: Array<PeerLatencyMeasurement>
  /** Average latency across peers */
  averageLatencyMs: number
  /** Latency variance */
  latencyVariance: number
  /** Timestamp of measurements */
  measurementTime: number
  /** Geographic location proof (optional) */
  locationProof?: Buffer
}
/** Individual peer latency measurement */
export interface PeerLatencyMeasurement {
  /** Peer identifier */
  peerId: Buffer
  /** Round-trip latency in milliseconds */
  latencyMs: number
  /** Number of samples taken */
  sampleCount: number
  /** Measurement timestamp */
  timestamp: number
}
/** Enhanced ownership commitment with prover-specific encoding */
export interface EnhancedOwnershipCommitment {
  /** Prover's public key (32 bytes) */
  publicKey: Buffer
  /** SHA256 hash of the encoded data (32 bytes)   */
  encodedDataHash: Buffer
  /** SHA256 hash of the original data (32 bytes) */
  originalDataHash: Buffer
  /** Encoding parameters used */
  encodingParams: Buffer
  /** Enhanced commitment hash */
  commitmentHash: Buffer
}
/** Enhanced physical access commitment with memory-hard VDF */
export interface EnhancedPhysicalAccessCommitment {
  /** Blockchain block height */
  blockHeight: number
  /** Previous commitment in chain (32 bytes) */
  previousCommitment: Buffer
  /** Current block hash (32 bytes) */
  blockHash: Buffer
  /** Multi-source entropy used */
  entropy: MultiSourceEntropy
  /** Enhanced chunk selection (16 chunks) */
  selectedChunks: Array<number>
  /** SHA256 hashes of selected chunks */
  chunkHashes: Array<Buffer>
  /** Memory-hard VDF proof */
  vdfProof: MemoryHardVdfProof
  /** Availability challenge responses */
  availabilityResponses: Array<AvailabilityResponse>
  /** Network latency proof */
  networkLatencyProof: NetworkLatencyProof
  /** Enhanced commitment hash */
  commitmentHash: Buffer
}
/** Enhanced chunk selection result with multi-source entropy */
export interface EnhancedChunkSelectionResult {
  /** Selected chunk indices (16 chunks) */
  selectedIndices: Array<number>
  /** Algorithm version used */
  algorithmVersion: number
  /** Total chunks in file */
  totalChunks: number
  /** Multi-source entropy used */
  entropy: MultiSourceEntropy
  /** Hash of selection parameters for verification */
  verificationHash: Buffer
  /** Proof that selection is unpredictable */
  unpredictabilityProof: Buffer
}
/** Bond information for economic security */
export interface BondInfo {
  /** Bond identifier */
  bondId: Buffer
  /** Amount bonded in base token units */
  amount: number
  /** Bond holder's identifier */
  holderId: Buffer
  /** Block height when bond was created */
  creationHeight: number
  /** Block height when bond can be released */
  releaseHeight: number
  /** Bond purpose/type */
  bondType: string
}
/** Checkpoint data with enhanced security */
export interface EnhancedCheckpoint {
  /** Checkpoint hash (32 bytes) */
  checkpointHash: Buffer
  /** Block height of checkpoint */
  blockHeight: number
  /** Global hierarchical root */
  globalRoot: Buffer
  /** Number of active chains */
  chainCount: number
  /** Cumulative work proof */
  cumulativeWork: Buffer
  /** Bond information */
  bondInfo: BondInfo
  /** Enhanced security proofs */
  securityProofs: Array<Buffer>
  /** Submitter identifier */
  submitterId: Buffer
}
/** File encoding information for prover-specific storage */
export interface FileEncodingInfo {
  /** Original file hash */
  originalHash: Buffer
  /** Encoded file hash */
  encodedHash: Buffer
  /** Prover's public key used for encoding */
  proverKey: Buffer
  /** Encoding algorithm version */
  encodingVersion: number
  /** Additional encoding parameters */
  encodingParams: Buffer
}
/** Enhanced chain metadata with new security features */
export interface EnhancedChainMetadata {
  /** Chain identifier */
  chainId: Buffer
  /** Prover's public key */
  proverKey: Buffer
  /** File encoding information */
  fileEncoding: FileEncodingInfo
  /** Registration bond information */
  registrationBond: BondInfo
  /** Last activity block height */
  lastActivityHeight: number
  /** Availability challenge history */
  availabilityScore: number
  /** Network latency history */
  latencyScore: number
  /** Chain status */
  status: string
}
/** Original ownership commitment binding data to a public key */
export interface OwnershipCommitment {
  /** Prover's public key (32 bytes) */
  publicKey: Buffer
  /** SHA256 hash of the data (32 bytes)   */
  dataHash: Buffer
  /** SHA256(data_hash || public_key) (32 bytes) */
  commitmentHash: Buffer
}
/** Block commitment from blockchain */
export interface BlockCommitment {
  /** Block height from blockchain */
  blockHeight: number
  /** Block hash from blockchain (32 bytes) */
  blockHash: Buffer
  /** Optional timestamp */
  timestamp?: number
}
/** Anchored ownership commitment combining ownership and blockchain state */
export interface AnchoredOwnershipCommitment {
  /** The ownership commitment */
  ownershipCommitment: OwnershipCommitment
  /** The blockchain commitment */
  blockCommitment: BlockCommitment
  /** SHA256(ownership_commitment || block_hash) (32 bytes) */
  anchoredHash: Buffer
}
/** Original physical access commitment proving data access at specific block */
export interface PhysicalAccessCommitment {
  /** Blockchain block height */
  blockHeight: number
  /** Previous commitment in chain (32 bytes) */
  previousCommitment: Buffer
  /** Current block hash (32 bytes) */
  blockHash: Buffer
  /** Indices of selected chunks */
  selectedChunks: Array<number>
  /** SHA256 hashes of selected chunks */
  chunkHashes: Array<Buffer>
  /** SHA256 of all above fields (32 bytes) */
  commitmentHash: Buffer
}
/** HashChain file header with metadata */
export interface HashChainHeader {
  /** File format identifier b'HCH2' */
  magic: Buffer
  /** Format version (must match HASHCHAIN_FORMAT_VERSION) */
  formatVersion: number
  /** SHA256 of original data file (32 bytes) */
  dataFileHash: Buffer
  /** Merkle root of chunks (32 bytes) */
  merkleRoot: Buffer
  /** Number of chunks (use f64 for large numbers in JS) */
  totalChunks: number
  /** Size of each chunk in bytes (4 bytes) */
  chunkSize: number
  /** SHA256 of data file path for binding (32 bytes) */
  dataFilePathHash: Buffer
  /** Initial anchored commitment (32 bytes) */
  anchoredCommitment: Buffer
  /** Number of chain links (4 bytes) */
  chainLength: number
  /** Prover's public key (32 bytes) */
  publicKey: Buffer
  /** Initial blockchain block height (8 bytes) */
  initialBlockHeight: number
  /** Initial blockchain block hash (32 bytes) */
  initialBlockHash: Buffer
  /** SHA256 of header fields (32 bytes) */
  headerChecksum: Buffer
}
/** Proof window containing last 5 commitments for verification (updated) */
export interface ProofWindow {
  /** Last 5 commitments (updated from 8) */
  commitments: Array<PhysicalAccessCommitment>
  /** Merkle proofs for selected chunks */
  merkleProofs: Array<Buffer>
  /** Commitment from 5 blocks ago */
  startCommitment: Buffer
  /** Latest commitment */
  endCommitment: Buffer
}
/** Original result of chunk selection with verification data */
export interface ChunkSelectionResult {
  /** Selected chunk indices */
  selectedIndices: Array<number>
  /** Algorithm version used */
  algorithmVersion: number
  /** Total chunks in file */
  totalChunks: number
  /** Block hash used for selection */
  blockHash: Buffer
  /** Hash of selection parameters for verification */
  verificationHash: Buffer
}
/** Complete chain data structure */
export interface ChainData {
  /** Anchored commitment hash (hex) */
  anchoredCommitment: string
  /** Initial blockchain block height */
  initialBlockHeight: number
  /** Initial blockchain block hash (hex) */
  initialBlockHash: string
  /** Total number of chunks */
  totalChunks: number
  /** Consensus algorithm version */
  consensusAlgorithmVersion: number
  /** Chain length */
  chainLength: number
  /** All commitments in the chain */
  commitments: Array<PhysicalAccessCommitment>
}
/** Human-readable information about HashChain state */
export interface HashChainInfo {
  /** Current status: "uninitialized", "initialized", "building", "active" */
  status: string
  /** Total number of chunks in the data file */
  totalChunks: number
  /** Number of blocks added to the chain */
  chainLength: number
  /** Size of each chunk in bytes (4096) */
  chunkSizeBytes: number
  /** Total storage required in MB */
  totalStorageMb: number
  /** Path to .hashchain file */
  hashchainFilePath?: string
  /** Path to .data file */
  dataFilePath?: string
  /** Size of .hashchain file in bytes */
  hashchainFileSizeBytes?: number
  /** Size of .data file in bytes */
  dataFileSizeBytes?: number
  /** Anchored commitment hash (hex) */
  anchoredCommitment?: string
  /** Current commitment hash (hex) */
  currentCommitment?: string
  /** Whether proof window is ready (5+ blocks) */
  proofWindowReady: boolean
  /** Blocks remaining until proof window ready */
  blocksUntilProofReady?: number
  /** Consensus algorithm version */
  consensusAlgorithmVersion: number
  /** Initial blockchain block height */
  initialBlockHeight: number
  /** Complete chain data as structured object */
  chainDataJson?: ChainData
}
/** Ultra-compact proof for audits (exactly 136 bytes) - Enhanced */
export interface UltraCompactProof {
  /** Chain hash (32 bytes) */
  chainHash: Buffer
  /** Chain length (8 bytes) */
  chainLength: number
  /** Global proof reference (32 bytes) */
  globalProofReference: Buffer
  /** Global block height (8 bytes) */
  globalBlockHeight: number
  /** Hierarchical position (32 bytes) */
  hierarchicalPosition: Buffer
  /** Total chains count (4 bytes) */
  totalChainsCount: number
  /** Proof timestamp (8 bytes) */
  proofTimestamp: number
  /** Proof nonce (12 bytes) */
  proofNonce: Buffer
}
/** Format B: Compact Proof (Enhanced - ~2KB) */
export interface CompactProof {
  /** Chain hash (32 bytes) */
  chainHash: Buffer
  /** Chain length (8 bytes) */
  chainLength: number
  /** Last 5 commitments (5 * ~200 = 1000 bytes) */
  proofWindow: Array<PhysicalAccessCommitment>
  /** Group proof hash (32 bytes) */
  groupProof: Buffer
  /** Regional proof hash (32 bytes) */
  regionalProof: Buffer
  /** Global proof reference (32 bytes) */
  globalProofReference: Buffer
  /** Merkle path to group (up to 512 bytes) */
  merklePath: Array<Buffer>
  /** Enhanced proof metadata (128 bytes) */
  metadata: ProofMetadata
}
/** Format C: Full Proof (Enhanced - ~32KB) */
export interface FullProof {
  /** Chain hash (32 bytes) */
  chainHash: Buffer
  /** Complete chain data */
  chainData: ChainData
  /** All group proofs in region (10 * 32 = 320 bytes) */
  groupProofs: Array<Buffer>
  /** All regional proofs (10 * 32 = 320 bytes) */
  regionalProofs: Array<Buffer>
  /** Global hierarchical proof (32 bytes) */
  globalProof: Buffer
  /** Complete merkle paths for verification (up to 16 KB) */
  merklePaths: Array<Array<Buffer>>
  /** Chunk verification data with enhanced security (up to 8 KB) */
  chunkVerification: ChunkVerificationData
  /** Full metadata and statistics (up to 4 KB) */
  fullMetadata: FullProofMetadata
}
/** Format D: Hierarchical Path Proof (Enhanced - 256 bytes) */
export interface HierarchicalPathProof {
  /** Chain ID (32 bytes) */
  chainId: Buffer
  /** Group ID hash (32 bytes) */
  groupId: Buffer
  /** Region ID hash (32 bytes) */
  regionId: Buffer
  /** Path to global root (96 bytes) */
  hierarchicalPath: Buffer
  /** Current position in hierarchy (32 bytes) */
  position: HierarchicalPosition
  /** Validation timestamp (8 bytes) */
  timestamp: number
  /** Path verification nonce (16 bytes) */
  verificationNonce: Buffer
  /** Enhanced security proof (8 bytes) */
  securityProof: Buffer
}
/** Enhanced proof metadata */
export interface ProofMetadata {
  /** Proof generation timestamp */
  timestamp: number
  /** Total chains in system */
  totalChains: number
  /** Algorithm version (v2 enhanced) */
  version: number
  /** Proof type identifier */
  proofType: string
  /** Memory-hard VDF metadata */
  vdfMetadata?: string
  /** Availability challenge count */
  availabilityChallenges: number
}
/** Enhanced chunk verification data */
export interface ChunkVerificationData {
  /** Selected chunk indices (16 chunks) */
  selectedChunks: Array<number>
  /** Chunk hashes */
  chunkHashes: Array<Buffer>
  /** Chunk merkle proofs */
  chunkProofs: Array<Buffer>
  /** File integrity hash */
  fileHash: Buffer
  /** Prover-specific encoding proof */
  encodingProof: Buffer
  /** Memory-hard VDF proof for chunk access */
  vdfProof?: MemoryHardVdfProof
}
/** Enhanced full proof metadata */
export interface FullProofMetadata {
  /** Detailed system statistics */
  systemStats: string
  /** Performance metrics including VDF */
  performanceMetrics: string
  /** Verification instructions */
  verificationGuide: string
  /** Proof generation time */
  generationTimeMs: number
  /** Memory usage during generation */
  memoryUsageMb: number
  /** Enhanced security features used */
  securityFeatures: Array<string>
}
/** Enhanced hierarchical position */
export interface HierarchicalPosition {
  /** Level in hierarchy (0-3) */
  level: number
  /** Position at this level */
  position: number
  /** Total items at this level */
  totalAtLevel: number
  /** Parent position */
  parentPosition?: number
  /** Enhanced security score */
  securityScore?: number
}
/** Storage commitment proving data possession for new interface */
export interface StorageCommitment {
  /** Prover's public key */
  proverKey: Buffer
  /** Data file hash */
  dataHash: Buffer
  /** Block height when committed */
  blockHeight: number
  /** Block hash for entropy */
  blockHash: Buffer
  /** Selected chunk indices */
  selectedChunks: Array<number>
  /** Hashes of selected chunks */
  chunkHashes: Array<Buffer>
  /** Memory-hard VDF proof */
  vdfProof: MemoryHardVdfProof
  /** Multi-source entropy used */
  entropy: MultiSourceEntropy
  /** Commitment hash */
  commitmentHash: Buffer
}
/** Challenge issued to prover for data availability */
export interface StorageChallenge {
  /** Challenge identifier */
  challengeId: Buffer
  /** Target prover */
  proverKey: Buffer
  /** Data commitment being challenged */
  commitmentHash: Buffer
  /** Specific chunk indices to prove */
  challengedChunks: Array<number>
  /** Challenge nonce for uniqueness */
  nonce: Buffer
  /** Challenge timestamp */
  timestamp: number
  /** Response deadline */
  deadline: number
}
/** Proof response to storage challenge */
export interface ChallengeResponse {
  /** Challenge being responded to */
  challengeId: Buffer
  /** Actual chunk data */
  chunkData: Array<Buffer>
  /** Merkle proofs for chunks */
  merkleProofs: Array<Buffer>
  /** Response timestamp */
  timestamp: number
  /** VDF proof of timely access */
  accessProof: MemoryHardVdfProof
}
/** Compact proof for efficient verification */
export interface CompactStorageProof {
  /** Prover identification */
  proverKey: Buffer
  /** Data commitment hash */
  commitmentHash: Buffer
  /** Block height reference */
  blockHeight: number
  /** Sampled chunk proofs (subset) */
  chunkProofs: Array<Buffer>
  /** Aggregated VDF proof */
  vdfProof: MemoryHardVdfProof
  /** Network position in hierarchy */
  networkPosition: Buffer
  /** Proof generation timestamp */
  timestamp: number
}
/** Full verification proof with complete data */
export interface FullStorageProof {
  /** Prover identification */
  proverKey: Buffer
  /** Complete storage commitment */
  commitment: StorageCommitment
  /** All chunk hashes */
  allChunkHashes: Array<Buffer>
  /** Complete merkle tree */
  merkleTree: Array<Buffer>
  /** Full VDF computation chain */
  vdfChain: Array<MemoryHardVdfProof>
  /** Network consensus proofs */
  networkProofs: Array<Buffer>
  /** Metadata and statistics */
  metadata: ProofMetadata
}
/** Network node information */
export interface NetworkNode {
  /** Node public key */
  nodeKey: Buffer
  /** Node type: "prover" | "verifier" | "both" */
  nodeType: string
  /** Node reputation score */
  reputation: number
  /** Last activity timestamp */
  lastActivity: number
  /** Network position */
  position: Buffer
}
/** Network statistics */
export interface NetworkStats {
  /** Total active provers */
  totalProvers: number
  /** Total active verifiers */
  totalVerifiers: number
  /** Network health score */
  healthScore: number
  /** Total storage committed */
  totalStorage: number
  /** Challenge success rate */
  challengeSuccessRate: number
}
/** Blockchain operations for provers */
export interface ProverBlockchainCallbacks {
  /** Get current blockchain height */
  getCurrentBlockHeight: (...args: any[]) => any
  /** Get block hash at specific height */
  getBlockHash: (...args: any[]) => any
  /** Get blockchain entropy */
  getBlockchainEntropy: (...args: any[]) => any
  /** Submit commitment to blockchain */
  submitCommitment: (...args: any[]) => any
}
/** Economic operations for provers */
export interface ProverEconomicCallbacks {
  /** Stake tokens for participation */
  stakeTokens: (...args: any[]) => any
  /** Get current stake amount */
  getStakeAmount: (...args: any[]) => any
  /** Handle stake slashing */
  onStakeSlashed: (...args: any[]) => any
  /** Claim storage rewards */
  claimRewards: (...args: any[]) => any
}
/** Storage operations for provers */
export interface ProverStorageCallbacks {
  /** Store chunk data to disk */
  storeChunk: (...args: any[]) => any
  /** Retrieve chunk data from disk */
  retrieveChunk: (...args: any[]) => any
  /** Verify data integrity */
  verifyDataIntegrity: (...args: any[]) => any
  /** Get storage statistics */
  getStorageStats: (...args: any[]) => any
}
/** Network operations for provers */
export interface ProverNetworkCallbacks {
  /** Announce availability to network */
  announceAvailability: (...args: any[]) => any
  /** Respond to challenges */
  submitChallengeResponse: (...args: any[]) => any
  /** Broadcast proof to network */
  broadcastProof: (...args: any[]) => any
}
/** Peer network management operations */
export interface PeerNetworkCallbacks {
  /** Register peer connection */
  registerPeer: (...args: any[]) => any
  /** Get peer information by ID */
  getPeerInfo: (...args: any[]) => any
  /** Update peer latency metrics */
  updatePeerLatency: (...args: any[]) => any
  /** Remove disconnected peer */
  removePeer: (...args: any[]) => any
  /** Get all active peer IDs */
  getActivePeers: (...args: any[]) => any
}
/** Availability challenge coordination callbacks */
export interface AvailabilityChallengeCallbacks {
  /** Issue availability challenge to network */
  issueAvailabilityChallenge: (...args: any[]) => any
  /** Validate availability response */
  validateAvailabilityResponse: (...args: any[]) => any
  /** Get challenge difficulty parameters */
  getChallengeDifficulty: (...args: any[]) => any
  /** Report challenge result to network */
  reportChallengeResult: (...args: any[]) => any
  /** Get prover availability score */
  getProverAvailabilityScore: (...args: any[]) => any
}
/** Blockchain data validation callbacks */
export interface BlockchainDataCallbacks {
  /** Validate data chunk count against blockchain */
  validateChunkCount: (...args: any[]) => any
  /** Get registered data file metadata */
  getDataFileMetadata: (...args: any[]) => any
  /** Verify data file registration */
  verifyDataRegistration: (...args: any[]) => any
  /** Get blockchain confirmed storage size */
  getConfirmedStorageSize: (...args: any[]) => any
  /** Update data availability status */
  updateAvailabilityStatus: (...args: any[]) => any
}
/** Combined prover callbacks */
export interface ProverCallbacks {
  /** Blockchain operations */
  blockchain: ProverBlockchainCallbacks
  /** Economic operations */
  economic: ProverEconomicCallbacks
  /** Storage operations */
  storage: ProverStorageCallbacks
  /** Network operations */
  network: ProverNetworkCallbacks
  /** Peer network management */
  peerNetwork: PeerNetworkCallbacks
  /** Availability challenge coordination */
  availabilityChallenge: AvailabilityChallengeCallbacks
  /** Blockchain data validation */
  blockchainData: BlockchainDataCallbacks
}
/** Blockchain operations for verifiers */
export interface VerifierBlockchainCallbacks {
  /** Get current blockchain height */
  getCurrentBlockHeight: (...args: any[]) => any
  /** Get block hash at specific height */
  getBlockHash: (...args: any[]) => any
  /** Validate block hash */
  validateBlockHash: (...args: any[]) => any
  /** Get commitment from blockchain */
  getCommitment: (...args: any[]) => any
}
/** Challenge operations for verifiers */
export interface VerifierChallengeCallbacks {
  /** Issue challenge to prover */
  issueChallenge: (...args: any[]) => any
  /** Validate challenge response */
  validateResponse: (...args: any[]) => any
  /** Report verification result */
  reportResult: (...args: any[]) => any
}
/** Network operations for verifiers */
export interface VerifierNetworkCallbacks {
  /** Discover active provers */
  discoverProvers: (...args: any[]) => any
  /** Get prover reputation */
  getProverReputation: (...args: any[]) => any
  /** Report prover misbehavior */
  reportMisbehavior: (...args: any[]) => any
}
/** Economic operations for verifiers */
export interface VerifierEconomicCallbacks {
  /** Reward successful verification */
  rewardVerification: (...args: any[]) => any
  /** Penalize failed verification */
  penalizeFailure: (...args: any[]) => any
}
/**
 * Peer network management operations
 * Combined verifier callbacks
 */
export interface VerifierCallbacks {
  /** Blockchain operations */
  blockchain: VerifierBlockchainCallbacks
  /** Challenge operations */
  challenge: VerifierChallengeCallbacks
  /** Network operations */
  network: VerifierNetworkCallbacks
  /** Economic operations */
  economic: VerifierEconomicCallbacks
  /** Peer network management */
  peerNetwork: PeerNetworkCallbacks
  /** Availability challenge coordination */
  availabilityChallenge: AvailabilityChallengeCallbacks
  /** Blockchain data validation */
  blockchainData: BlockchainDataCallbacks
}
/** Generate secure multi-source entropy */
export declare function generateMultiSourceEntropy(blockHash: Buffer, beaconData?: Buffer | undefined | null): MultiSourceEntropy
/** Create memory-hard VDF proof */
export declare function createMemoryHardVdfProof(input: Buffer, iterations: number): MemoryHardVdfProof
/** Verify memory-hard VDF proof */
export declare function verifyMemoryHardVdfProof(proof: MemoryHardVdfProof): boolean
/** Select chunks deterministically from entropy */
export declare function selectChunksFromEntropy(entropy: MultiSourceEntropy, totalChunks: number, count: number): Array<number>
/** Verify chunk selection algorithm */
export declare function verifyChunkSelection(entropy: MultiSourceEntropy, totalChunks: number, selectedChunks: Array<number>): boolean
/** Create storage commitment hash */
export declare function createCommitmentHash(commitment: StorageCommitment): Buffer
/** Verify commitment integrity */
export declare function verifyCommitmentIntegrity(commitment: StorageCommitment): boolean
/**
 * Proof of Storage Prover
 * Handles data storage, commitment generation, and proof creation
 */
export declare class ProofOfStorageProver {
  /** Create new prover instance */
  constructor(proverKey: Buffer, callbacks: ProverCallbacks)
  /** Store data and generate initial commitment */
  storeData(data: Buffer, outputDirectory: string): StorageCommitment
  /** Generate storage commitment for current block */
  generateCommitment(blockHeight?: number | undefined | null): StorageCommitment
  /** Create compact proof for efficient verification */
  createCompactProof(): CompactStorageProof
  /** Create full proof with complete verification data */
  createFullProof(): FullStorageProof
  /** Respond to storage challenge */
  respondToChallenge(challenge: StorageChallenge): ChallengeResponse
  /** Get prover statistics */
  getProverStats(): string
  /** Verify own data integrity */
  verifySelfIntegrity(): boolean
  /** Update prover callbacks */
  updateCallbacks(callbacks: ProverCallbacks): void
  /** Register peer for network operations */
  registerPeer(peerId: string, peerInfo: string): boolean
  /** Issue availability challenge through network */
  issueAvailabilityChallenge(targetProver: Buffer): string
  /** Validate chunk count against blockchain */
  validateChunkCount(fileHash: Buffer, reportedChunks: number): boolean
  /** Get peer network information */
  getPeerInfo(peerId: string): string
  /** Update peer latency metrics */
  updatePeerLatency(peerId: string, latencyMs: number): boolean
}
/**
 * Proof of Storage Verifier
 * Handles proof verification, challenge generation, and network monitoring
 */
export declare class ProofOfStorageVerifier {
  /** Create new verifier instance */
  constructor(verifierKey: Buffer, callbacks: VerifierCallbacks)
  /** Verify compact storage proof */
  verifyCompactProof(proof: CompactStorageProof): boolean
  /** Verify full storage proof */
  verifyFullProof(proof: FullStorageProof): boolean
  /** Verify challenge response */
  verifyChallengeResponse(response: ChallengeResponse, originalChallenge: StorageChallenge): boolean
  /** Generate challenge for prover */
  generateChallenge(proverKey: Buffer, commitmentHash: Buffer): StorageChallenge
  /** Audit prover data availability */
  auditProver(proverKey: Buffer): boolean
  /** Get verifier statistics */
  getVerifierStats(): string
  /** Monitor network for misbehavior */
  monitorNetwork(): Array<string>
  /** Update verifier callbacks */
  updateCallbacks(callbacks: VerifierCallbacks): void
  /** Discover active provers through network callbacks */
  discoverActiveProvers(): Array<string>
  /** Get prover reputation score */
  getProverReputation(proverKey: Buffer): number
  /** Validate availability response through challenge callbacks */
  validateAvailabilityResponse(response: ChallengeResponse): boolean
  /** Report challenge result to network */
  reportChallengeResult(challengeId: Buffer, result: string): boolean
  /** Get confirmed storage size from blockchain */
  getConfirmedStorageSize(proverKey: Buffer): number
}
/**
 * Hierarchical Network Manager
 * Manages the proof-of-storage network with hierarchical organization
 */
export declare class HierarchicalNetworkManager {
  /** Create new network manager */
  constructor(nodeKey: Buffer, nodeType: string)
  /** Register prover in network */
  registerProver(prover: ProofOfStorageProver): boolean
  /** Register verifier in network */
  registerVerifier(verifier: ProofOfStorageVerifier): boolean
  /** Remove node from network */
  removeNode(nodeKey: Buffer): boolean
  /** Process network block */
  processNetworkBlock(blockHeight: number, blockHash: Buffer): void
  /** Get network statistics */
  getNetworkStats(): NetworkStats
  /** Get active nodes */
  getActiveNodes(): Array<NetworkNode>
  /** Perform network consensus */
  performConsensus(): boolean
  /** Handle network reorganization */
  reorganizeNetwork(): void
  /** Get this node's key */
  getNodeKey(): Buffer
  /** Get this node's type */
  getNodeType(): string
  /** Check if this node can act as specified type */
  canActAs(role: string): boolean
  /** Get node identity for network operations */
  getNodeIdentity(): string
}
