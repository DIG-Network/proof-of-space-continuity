/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Ownership commitment binding data to a public key */
export interface OwnershipCommitment {
  /** Prover's public key (32 bytes) */
  publicKey: Buffer
  /** SHA256 hash of the data (32 bytes)   */
  dataHash: Buffer
  /** SHA256(data_hash || public_key) (32 bytes) */
  commitmentHash: Buffer
}
/** Block commitment from blockchain */
export interface BlockCommitment {
  /** Block height from Chia blockchain */
  blockHeight: number
  /** Block hash from Chia blockchain (32 bytes) */
  blockHash: Buffer
}
/** Anchored ownership commitment combining ownership and blockchain state */
export interface AnchoredOwnershipCommitment {
  /** The ownership commitment */
  ownershipCommitment: OwnershipCommitment
  /** The blockchain commitment */
  blockCommitment: BlockCommitment
  /** SHA256(ownership_commitment || block_hash) (32 bytes) */
  anchoredHash: Buffer
}
/** Physical access commitment proving data access at specific block */
export interface PhysicalAccessCommitment {
  /** Blockchain block height */
  blockHeight: number
  /** Previous commitment in chain (32 bytes) */
  previousCommitment: Buffer
  /** Current block hash (32 bytes) */
  blockHash: Buffer
  /** Indices of selected chunks */
  selectedChunks: Array<number>
  /** SHA256 hashes of selected chunks */
  chunkHashes: Array<Buffer>
  /** SHA256 of all above fields (32 bytes) */
  commitmentHash: Buffer
}
/** HashChain file header with metadata */
export interface HashChainHeader {
  /** File format identifier b'HCHN' */
  magic: Buffer
  /** Format version (must match HASHCHAIN_FORMAT_VERSION) */
  formatVersion: number
  /** SHA256 of original data file (32 bytes) */
  dataFileHash: Buffer
  /** Merkle root of chunks (32 bytes) */
  merkleRoot: Buffer
  /** Number of chunks (use f64 for large numbers in JS) */
  totalChunks: number
  /** Size of each chunk in bytes (4 bytes) */
  chunkSize: number
  /** SHA256 of data file path for binding (32 bytes) */
  dataFilePathHash: Buffer
  /** Initial anchored commitment (32 bytes) */
  anchoredCommitment: Buffer
  /** Number of chain links (4 bytes) */
  chainLength: number
  /** Prover's public key (32 bytes) */
  publicKey: Buffer
  /** Initial blockchain block height (8 bytes) */
  initialBlockHeight: number
  /** Initial blockchain block hash (32 bytes) */
  initialBlockHash: Buffer
  /** SHA256 of header fields (32 bytes) */
  headerChecksum: Buffer
}
/** Proof window containing last 8 commitments for verification */
export interface ProofWindow {
  /** Last 8 commitments */
  commitments: Array<PhysicalAccessCommitment>
  /** Merkle proofs for selected chunks */
  merkleProofs: Array<Buffer>
  /** Commitment from 8 blocks ago */
  startCommitment: Buffer
  /** Latest commitment */
  endCommitment: Buffer
}
/** Result of chunk selection with verification data */
export interface ChunkSelectionResult {
  /** Selected chunk indices */
  selectedIndices: Array<number>
  /** Algorithm version used */
  algorithmVersion: number
  /** Total chunks in file */
  totalChunks: number
  /** Block hash used for selection */
  blockHash: Buffer
  /** Hash of selection parameters for verification */
  verificationHash: Buffer
}
/** Complete chain data structure */
export interface ChainData {
  /** Anchored commitment hash (hex) */
  anchoredCommitment: string
  /** Initial blockchain block height */
  initialBlockHeight: number
  /** Initial blockchain block hash (hex) */
  initialBlockHash: string
  /** Total number of chunks */
  totalChunks: number
  /** Consensus algorithm version */
  consensusAlgorithmVersion: number
  /** Chain length */
  chainLength: number
  /** All commitments in the chain */
  commitments: Array<PhysicalAccessCommitment>
}
/** Human-readable information about HashChain state */
export interface HashChainInfo {
  /** Current status: "uninitialized", "initialized", "building", "active" */
  status: string
  /** Total number of chunks in the data file */
  totalChunks: number
  /** Number of blocks added to the chain */
  chainLength: number
  /** Size of each chunk in bytes (4096) */
  chunkSizeBytes: number
  /** Total storage required in MB */
  totalStorageMb: number
  /** Path to .hashchain file */
  hashchainFilePath?: string
  /** Path to .data file */
  dataFilePath?: string
  /** Size of .hashchain file in bytes */
  hashchainFileSizeBytes?: number
  /** Size of .data file in bytes */
  dataFileSizeBytes?: number
  /** Anchored commitment hash (hex) */
  anchoredCommitment?: string
  /** Current commitment hash (hex) */
  currentCommitment?: string
  /** Whether proof window is ready (8+ blocks) */
  proofWindowReady: boolean
  /** Blocks remaining until proof window ready */
  blocksUntilProofReady?: number
  /** Consensus algorithm version */
  consensusAlgorithmVersion: number
  /** Initial blockchain block height */
  initialBlockHeight: number
  /** Complete chain data as structured object */
  chainDataJson?: ChainData
}
/** Ultra-compact proof for audits (exactly 136 bytes) */
export interface UltraCompactProof {
  /** Chain hash (32 bytes) */
  chainHash: Buffer
  /** Chain length (8 bytes) */
  chainLength: number
  /** Global proof reference (32 bytes) */
  globalProofReference: Buffer
  /** Global block height (8 bytes) */
  globalBlockHeight: number
  /** Hierarchical position (32 bytes) */
  hierarchicalPosition: Buffer
  /** Total chains count (4 bytes) */
  totalChainsCount: number
  /** Proof timestamp (8 bytes) */
  proofTimestamp: number
  /** Proof nonce (12 bytes) */
  proofNonce: Buffer
}
/** Format B: Compact Proof (1.6 KB - Standard verification) */
export interface CompactProof {
  /** Chain hash (32 bytes) */
  chainHash: Buffer
  /** Chain length (8 bytes) */
  chainLength: number
  /** Last 8 commitments (8 * 136 = 1088 bytes) */
  proofWindow: Array<PhysicalAccessCommitment>
  /** Group proof hash (32 bytes) */
  groupProof: Buffer
  /** Regional proof hash (32 bytes) */
  regionalProof: Buffer
  /** Global proof reference (32 bytes) */
  globalProofReference: Buffer
  /** Merkle path to group (up to 256 bytes) */
  merklePath: Array<Buffer>
  /** Proof metadata (64 bytes) */
  metadata: ProofMetadata
}
/** Format C: Full Proof (16 KB - Complete verification) */
export interface FullProof {
  /** Chain hash (32 bytes) */
  chainHash: Buffer
  /** Complete chain data */
  chainData: ChainData
  /** All group proofs in region (10 * 32 = 320 bytes) */
  groupProofs: Array<Buffer>
  /** All regional proofs (10 * 32 = 320 bytes) */
  regionalProofs: Array<Buffer>
  /** Global hierarchical proof (32 bytes) */
  globalProof: Buffer
  /** Complete merkle paths for verification (up to 8 KB) */
  merklePaths: Array<Array<Buffer>>
  /** Chunk verification data (up to 4 KB) */
  chunkVerification: ChunkVerificationData
  /** Full metadata and statistics (up to 2 KB) */
  fullMetadata: FullProofMetadata
}
/** Format D: Hierarchical Path Proof (200 bytes - Path validation) */
export interface HierarchicalPathProof {
  /** Chain ID (32 bytes) */
  chainId: Buffer
  /** Group ID hash (32 bytes) */
  groupId: Buffer
  /** Region ID hash (32 bytes) */
  regionId: Buffer
  /** Path to global root (64 bytes) */
  hierarchicalPath: Buffer
  /** Current position in hierarchy (8 bytes) */
  position: HierarchicalPosition
  /** Validation timestamp (8 bytes) */
  timestamp: number
  /** Path verification nonce (16 bytes) */
  verificationNonce: Buffer
}
/** Proof metadata for compact proofs */
export interface ProofMetadata {
  /** Proof generation timestamp */
  timestamp: number
  /** Total chains in system */
  totalChains: number
  /** Algorithm version */
  version: number
  /** Proof type identifier */
  proofType: string
}
/** Chunk verification data for full proofs */
export interface ChunkVerificationData {
  /** Selected chunk indices */
  selectedChunks: Array<number>
  /** Chunk hashes */
  chunkHashes: Array<Buffer>
  /** Chunk merkle proofs */
  chunkProofs: Array<Buffer>
  /** File integrity hash */
  fileHash: Buffer
}
/** Full proof metadata with statistics */
export interface FullProofMetadata {
  /** Detailed system statistics */
  systemStats: string
  /** Performance metrics */
  performanceMetrics: string
  /** Verification instructions */
  verificationGuide: string
  /** Proof generation time */
  generationTimeMs: number
}
/** Hierarchical position in the proof tree */
export interface HierarchicalPosition {
  /** Level in hierarchy (0-3) */
  level: number
  /** Position at this level */
  position: number
  /** Total items at this level */
  totalAtLevel: number
  /** Parent position */
  parentPosition?: number
}
/** CONSENSUS CRITICAL: Standardized chunk selection algorithm V1 */
export declare function selectChunksV1(blockHash: Buffer, totalChunks: number): ChunkSelectionResult
/** Verify chunk selection matches network consensus algorithm */
export declare function verifyChunkSelection(blockHash: Buffer, totalChunks: number, claimedIndices: Array<number>, expectedAlgorithmVersion?: number | undefined | null): boolean
/** Create ownership commitment */
export declare function createOwnershipCommitment(publicKey: Buffer, dataHash: Buffer): OwnershipCommitment
/** Create anchored ownership commitment */
export declare function createAnchoredOwnershipCommitment(ownershipCommitment: OwnershipCommitment, blockCommitment: BlockCommitment): AnchoredOwnershipCommitment
/** Verify proof window for storage continuity */
export declare function verifyProofOfStorageContinuity(proofWindow: ProofWindow, anchoredCommitment: Buffer, merkleRoot: Buffer, totalChunks: number): boolean
/**
 * Main HashChain implementation for Proof of Storage Continuity
 * This is a wrapper around IndividualHashChain for NAPI bindings
 */
export declare class HashChain {
  /** Create new HashChain instance */
  constructor(publicKey: Buffer, blockHeight: number, blockHash: Buffer)
  /** Load existing HashChain from .hashchain file */
  static loadFromFile(hashchainFilePath: string): HashChain
  /** Stream data to files with SHA256-based naming */
  streamData(data: Buffer, outputDir: string): void
  /** Add new block to the hash chain */
  addBlock(blockHash: Buffer): PhysicalAccessCommitment
  /** Verify entire hash chain */
  verifyChain(): boolean
  /** Read chunk from data file */
  readChunk(chunkIdx: number): Buffer
  /** Get current chain length */
  getChainLength(): number
  /** Get total chunks */
  getTotalChunks(): number
  /** Get current commitment hash */
  getCurrentCommitment(): Buffer | null
  /** Get anchored commitment hash */
  getAnchoredCommitment(): Buffer | null
  /** Get file paths */
  getFilePaths(): Array<string> | null
  /** Get proof window for last 8 blocks (CONSENSUS CRITICAL) */
  getProofWindow(): ProofWindow
  /** Get file path for async operations (returns owned data) */
  getDataFilePath(): string | null
  /** Get comprehensive information about the HashChain state */
  getChainInfo(): HashChainInfo
}
/** Hierarchical Chain Manager for 100,000+ chains */
export declare class HierarchicalChainManager {
  /** Create new hierarchical manager */
  constructor(maxChains?: number | undefined | null)
  /** Add a HashChain instance to the hierarchical system */
  addChain(hashChain: HashChain, retentionPolicy?: string | undefined | null): string
  /** Remove a chain from the hierarchical system */
  removeChain(chainId: string, reason?: string | undefined | null, archiveData?: boolean | undefined | null): string
  /** Process a new blockchain block */
  processBlock(blockHash: Buffer, blockHeight: number): void
  /** Get statistics about the hierarchical system */
  getStatistics(): string
  /** Generate Format A: Ultra-compact proof for audit (136 bytes - Phase 1 audits) */
  generateUltraCompactProof(chainId: string, nonce: Buffer): UltraCompactProof
  /** Generate Format B: Compact proof (1.6 KB - Standard verification) */
  generateCompactProof(chainId: string, includeMerklePath?: boolean | undefined | null): CompactProof
  /** Generate Format C: Full proof (16 KB - Complete verification) */
  generateFullProof(chainId: string, includeChunkData?: boolean | undefined | null): FullProof
  /** Generate Format D: Hierarchical path proof (200 bytes - Path validation) */
  generateHierarchicalPathProof(chainId: string): HierarchicalPathProof
  /** Get hierarchical level statistics */
  getLevelStatistics(level: number): string
  /** Verify proof format and size */
  verifyProofFormat(proofType: string, proofData: Buffer): boolean
  /** Legacy method for backward compatibility - Generate ultra-compact proof */
  generateAuditProof(chainId: string, nonce: Buffer): UltraCompactProof
}
